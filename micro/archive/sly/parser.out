Grammar:

Rule 0     S' -> Module
Rule 1     Identifier -> ID
Rule 2     Type -> ID
Rule 3     Declaration -> Identifier : Type
Rule 4     VarDeclaration -> VAR Declaration
Rule 5     multiplicative -> multiplicative / UnaryExpression
Rule 6     multiplicative -> multiplicative * UnaryExpression
Rule 7     multiplicative -> UnaryExpression
Rule 8     addative -> addative - multiplicative
Rule 9     addative -> addative + multiplicative
Rule 10    addative -> multiplicative
Rule 11    BinaryOperation -> addative
Rule 12    Expression -> BinaryOperation
Rule 13    UnaryExpression -> ( Expression )
Rule 14    UnaryExpression -> Identifier
Rule 15    UnaryExpression -> NUMBER
Rule 16    Return -> RETURN Expression
Rule 17    Return -> RETURN
Rule 18    arg -> Identifier ,
Rule 19    arg -> Identifier
Rule 20    arg_list -> arg_list arg
Rule 21    arg_list -> arg
Rule 22    FunctionCall -> Identifier ( )
Rule 23    FunctionCall -> Identifier ( arg_list )
Rule 24    rvalue -> Identifier
Rule 25    rvalue -> Expression
Rule 26    rvalue -> FunctionCall
Rule 27    lvalue -> Identifier
Rule 28    lvalue -> VarDeclaration
Rule 29    AssignmentExpression -> lvalue = rvalue
Rule 30    statement -> VarDeclaration
Rule 31    statement -> AssignmentExpression
Rule 32    statement -> Return
Rule 33    statements -> statements statement
Rule 34    statements -> statement
Rule 35    arg_declaration_list -> arg_declaration
Rule 36    arg_declaration_list -> arg_declaration_list arg_declaration
Rule 37    arg_declaration -> Declaration ,
Rule 38    arg_declaration -> Declaration
Rule 39    CodeDefinition -> { }
Rule 40    CodeDefinition -> { statements }
Rule 41    CodeDeclaration -> CODE Declaration ( )
Rule 42    CodeDeclaration -> CODE Declaration ( arg_declaration_list )
Rule 43    Code -> CodeDeclaration CodeDefinition
Rule 44    global -> Code
Rule 45    global -> AssignmentExpression
Rule 46    globals -> globals global
Rule 47    globals -> global
Rule 48    Module -> globals

Terminals, with rules where they appear:

(                    : 13 22 23 41 42
)                    : 13 22 23 41 42
*                    : 6
+                    : 9
,                    : 18 37
-                    : 8
/                    : 5
:                    : 3
=                    : 29
CODE                 : 41 42
ID                   : 1 2
NUMBER               : 15
RETURN               : 16 17
VAR                  : 4
error                : 
{                    : 39 40
}                    : 39 40

Nonterminals, with rules where they appear:

AssignmentExpression : 31 45
BinaryOperation      : 12
Code                 : 44
CodeDeclaration      : 43
CodeDefinition       : 43
Declaration          : 4 37 38 41 42
Expression           : 13 16 25
FunctionCall         : 26
Identifier           : 3 14 18 19 22 23 24 27
Module               : 0
Return               : 32
Type                 : 3
UnaryExpression      : 5 6 7
VarDeclaration       : 28 30
addative             : 8 9 11
arg                  : 20 21
arg_declaration      : 35 36
arg_declaration_list : 36 42
arg_list             : 20 23
global               : 46 47
globals              : 46 48
lvalue               : 29
multiplicative       : 5 6 8 9 10
rvalue               : 29
statement            : 33 34
statements           : 33 40


state 0

    (0) S' -> . Module
    (48) Module -> . globals
    (46) globals -> . globals global
    (47) globals -> . global
    (44) global -> . Code
    (45) global -> . AssignmentExpression
    (43) Code -> . CodeDeclaration CodeDefinition
    (29) AssignmentExpression -> . lvalue = rvalue
    (41) CodeDeclaration -> . CODE Declaration ( )
    (42) CodeDeclaration -> . CODE Declaration ( arg_declaration_list )
    (27) lvalue -> . Identifier
    (28) lvalue -> . VarDeclaration
    (1) Identifier -> . ID
    (4) VarDeclaration -> . VAR Declaration
    CODE            shift and go to state 8
    ID              shift and go to state 11
    VAR             shift and go to state 12

    Module                         shift and go to state 1
    globals                        shift and go to state 2
    global                         shift and go to state 3
    Code                           shift and go to state 4
    AssignmentExpression           shift and go to state 5
    CodeDeclaration                shift and go to state 6
    lvalue                         shift and go to state 7
    Identifier                     shift and go to state 9
    VarDeclaration                 shift and go to state 10

state 1

    (0) S' -> Module .


state 2

    (48) Module -> globals .
    (46) globals -> globals . global
    (44) global -> . Code
    (45) global -> . AssignmentExpression
    (43) Code -> . CodeDeclaration CodeDefinition
    (29) AssignmentExpression -> . lvalue = rvalue
    (41) CodeDeclaration -> . CODE Declaration ( )
    (42) CodeDeclaration -> . CODE Declaration ( arg_declaration_list )
    (27) lvalue -> . Identifier
    (28) lvalue -> . VarDeclaration
    (1) Identifier -> . ID
    (4) VarDeclaration -> . VAR Declaration
    $end            reduce using rule 48 (Module -> globals .)
    CODE            shift and go to state 8
    ID              shift and go to state 11
    VAR             shift and go to state 12

    global                         shift and go to state 13
    Code                           shift and go to state 4
    AssignmentExpression           shift and go to state 5
    CodeDeclaration                shift and go to state 6
    lvalue                         shift and go to state 7
    Identifier                     shift and go to state 9
    VarDeclaration                 shift and go to state 10

state 3

    (47) globals -> global .
    CODE            reduce using rule 47 (globals -> global .)
    ID              reduce using rule 47 (globals -> global .)
    VAR             reduce using rule 47 (globals -> global .)
    $end            reduce using rule 47 (globals -> global .)


state 4

    (44) global -> Code .
    CODE            reduce using rule 44 (global -> Code .)
    ID              reduce using rule 44 (global -> Code .)
    VAR             reduce using rule 44 (global -> Code .)
    $end            reduce using rule 44 (global -> Code .)


state 5

    (45) global -> AssignmentExpression .
    CODE            reduce using rule 45 (global -> AssignmentExpression .)
    ID              reduce using rule 45 (global -> AssignmentExpression .)
    VAR             reduce using rule 45 (global -> AssignmentExpression .)
    $end            reduce using rule 45 (global -> AssignmentExpression .)


state 6

    (43) Code -> CodeDeclaration . CodeDefinition
    (39) CodeDefinition -> . { }
    (40) CodeDefinition -> . { statements }
    {               shift and go to state 15

    CodeDefinition                 shift and go to state 14

state 7

    (29) AssignmentExpression -> lvalue . = rvalue
    =               shift and go to state 16


state 8

    (41) CodeDeclaration -> CODE . Declaration ( )
    (42) CodeDeclaration -> CODE . Declaration ( arg_declaration_list )
    (3) Declaration -> . Identifier : Type
    (1) Identifier -> . ID
    ID              shift and go to state 11

    Declaration                    shift and go to state 17
    Identifier                     shift and go to state 18

state 9

    (27) lvalue -> Identifier .
    =               reduce using rule 27 (lvalue -> Identifier .)


state 10

    (28) lvalue -> VarDeclaration .
    =               reduce using rule 28 (lvalue -> VarDeclaration .)


state 11

    (1) Identifier -> ID .
    =               reduce using rule 1 (Identifier -> ID .)
    :               reduce using rule 1 (Identifier -> ID .)
    (               reduce using rule 1 (Identifier -> ID .)
    CODE            reduce using rule 1 (Identifier -> ID .)
    ID              reduce using rule 1 (Identifier -> ID .)
    VAR             reduce using rule 1 (Identifier -> ID .)
    $end            reduce using rule 1 (Identifier -> ID .)
    }               reduce using rule 1 (Identifier -> ID .)
    RETURN          reduce using rule 1 (Identifier -> ID .)
    /               reduce using rule 1 (Identifier -> ID .)
    *               reduce using rule 1 (Identifier -> ID .)
    -               reduce using rule 1 (Identifier -> ID .)
    +               reduce using rule 1 (Identifier -> ID .)
    )               reduce using rule 1 (Identifier -> ID .)
    ,               reduce using rule 1 (Identifier -> ID .)


state 12

    (4) VarDeclaration -> VAR . Declaration
    (3) Declaration -> . Identifier : Type
    (1) Identifier -> . ID
    ID              shift and go to state 11

    Declaration                    shift and go to state 19
    Identifier                     shift and go to state 18

state 13

    (46) globals -> globals global .
    CODE            reduce using rule 46 (globals -> globals global .)
    ID              reduce using rule 46 (globals -> globals global .)
    VAR             reduce using rule 46 (globals -> globals global .)
    $end            reduce using rule 46 (globals -> globals global .)


state 14

    (43) Code -> CodeDeclaration CodeDefinition .
    CODE            reduce using rule 43 (Code -> CodeDeclaration CodeDefinition .)
    ID              reduce using rule 43 (Code -> CodeDeclaration CodeDefinition .)
    VAR             reduce using rule 43 (Code -> CodeDeclaration CodeDefinition .)
    $end            reduce using rule 43 (Code -> CodeDeclaration CodeDefinition .)


state 15

    (39) CodeDefinition -> { . }
    (40) CodeDefinition -> { . statements }
    (33) statements -> . statements statement
    (34) statements -> . statement
    (30) statement -> . VarDeclaration
    (31) statement -> . AssignmentExpression
    (32) statement -> . Return
    (4) VarDeclaration -> . VAR Declaration
    (29) AssignmentExpression -> . lvalue = rvalue
    (16) Return -> . RETURN Expression
    (17) Return -> . RETURN
    (27) lvalue -> . Identifier
    (28) lvalue -> . VarDeclaration
    (1) Identifier -> . ID
    }               shift and go to state 20
    VAR             shift and go to state 12
    RETURN          shift and go to state 26
    ID              shift and go to state 11

    statements                     shift and go to state 21
    statement                      shift and go to state 22
    VarDeclaration                 shift and go to state 23
    AssignmentExpression           shift and go to state 24
    Return                         shift and go to state 25
    lvalue                         shift and go to state 7
    Identifier                     shift and go to state 9

state 16

    (29) AssignmentExpression -> lvalue = . rvalue
    (24) rvalue -> . Identifier
    (25) rvalue -> . Expression
    (26) rvalue -> . FunctionCall
    (1) Identifier -> . ID
    (12) Expression -> . BinaryOperation
    (22) FunctionCall -> . Identifier ( )
    (23) FunctionCall -> . Identifier ( arg_list )
    (11) BinaryOperation -> . addative
    (8) addative -> . addative - multiplicative
    (9) addative -> . addative + multiplicative
    (10) addative -> . multiplicative
    (5) multiplicative -> . multiplicative / UnaryExpression
    (6) multiplicative -> . multiplicative * UnaryExpression
    (7) multiplicative -> . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    ID              shift and go to state 11
    (               shift and go to state 32
    NUMBER          shift and go to state 36

    rvalue                         shift and go to state 27
    Identifier                     shift and go to state 28
    Expression                     shift and go to state 29
    FunctionCall                   shift and go to state 30
    BinaryOperation                shift and go to state 31
    addative                       shift and go to state 33
    multiplicative                 shift and go to state 34
    UnaryExpression                shift and go to state 35

state 17

    (41) CodeDeclaration -> CODE Declaration . ( )
    (42) CodeDeclaration -> CODE Declaration . ( arg_declaration_list )
    (               shift and go to state 37


state 18

    (3) Declaration -> Identifier . : Type
    :               shift and go to state 38


state 19

    (4) VarDeclaration -> VAR Declaration .
    =               reduce using rule 4 (VarDeclaration -> VAR Declaration .)
    }               reduce using rule 4 (VarDeclaration -> VAR Declaration .)
    VAR             reduce using rule 4 (VarDeclaration -> VAR Declaration .)
    RETURN          reduce using rule 4 (VarDeclaration -> VAR Declaration .)
    ID              reduce using rule 4 (VarDeclaration -> VAR Declaration .)


state 20

    (39) CodeDefinition -> { } .
    CODE            reduce using rule 39 (CodeDefinition -> { } .)
    ID              reduce using rule 39 (CodeDefinition -> { } .)
    VAR             reduce using rule 39 (CodeDefinition -> { } .)
    $end            reduce using rule 39 (CodeDefinition -> { } .)


state 21

    (40) CodeDefinition -> { statements . }
    (33) statements -> statements . statement
    (30) statement -> . VarDeclaration
    (31) statement -> . AssignmentExpression
    (32) statement -> . Return
    (4) VarDeclaration -> . VAR Declaration
    (29) AssignmentExpression -> . lvalue = rvalue
    (16) Return -> . RETURN Expression
    (17) Return -> . RETURN
    (27) lvalue -> . Identifier
    (28) lvalue -> . VarDeclaration
    (1) Identifier -> . ID
    }               shift and go to state 39
    VAR             shift and go to state 12
    RETURN          shift and go to state 26
    ID              shift and go to state 11

    statement                      shift and go to state 40
    VarDeclaration                 shift and go to state 23
    AssignmentExpression           shift and go to state 24
    Return                         shift and go to state 25
    lvalue                         shift and go to state 7
    Identifier                     shift and go to state 9

state 22

    (34) statements -> statement .
    }               reduce using rule 34 (statements -> statement .)
    VAR             reduce using rule 34 (statements -> statement .)
    RETURN          reduce using rule 34 (statements -> statement .)
    ID              reduce using rule 34 (statements -> statement .)


state 23

    (30) statement -> VarDeclaration .
    (28) lvalue -> VarDeclaration .
    }               reduce using rule 30 (statement -> VarDeclaration .)
    VAR             reduce using rule 30 (statement -> VarDeclaration .)
    RETURN          reduce using rule 30 (statement -> VarDeclaration .)
    ID              reduce using rule 30 (statement -> VarDeclaration .)
    =               reduce using rule 28 (lvalue -> VarDeclaration .)


state 24

    (31) statement -> AssignmentExpression .
    }               reduce using rule 31 (statement -> AssignmentExpression .)
    VAR             reduce using rule 31 (statement -> AssignmentExpression .)
    RETURN          reduce using rule 31 (statement -> AssignmentExpression .)
    ID              reduce using rule 31 (statement -> AssignmentExpression .)


state 25

    (32) statement -> Return .
    }               reduce using rule 32 (statement -> Return .)
    VAR             reduce using rule 32 (statement -> Return .)
    RETURN          reduce using rule 32 (statement -> Return .)
    ID              reduce using rule 32 (statement -> Return .)


state 26

    (16) Return -> RETURN . Expression
    (17) Return -> RETURN .
    (12) Expression -> . BinaryOperation
    (11) BinaryOperation -> . addative
    (8) addative -> . addative - multiplicative
    (9) addative -> . addative + multiplicative
    (10) addative -> . multiplicative
    (5) multiplicative -> . multiplicative / UnaryExpression
    (6) multiplicative -> . multiplicative * UnaryExpression
    (7) multiplicative -> . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    (1) Identifier -> . ID
  ! shift/reduce conflict for ID resolved as shift
    }               reduce using rule 17 (Return -> RETURN .)
    VAR             reduce using rule 17 (Return -> RETURN .)
    RETURN          reduce using rule 17 (Return -> RETURN .)
    (               shift and go to state 32
    NUMBER          shift and go to state 36
    ID              shift and go to state 11

    Expression                     shift and go to state 41
    BinaryOperation                shift and go to state 31
    addative                       shift and go to state 33
    multiplicative                 shift and go to state 34
    UnaryExpression                shift and go to state 35
    Identifier                     shift and go to state 42

state 27

    (29) AssignmentExpression -> lvalue = rvalue .
    CODE            reduce using rule 29 (AssignmentExpression -> lvalue = rvalue .)
    ID              reduce using rule 29 (AssignmentExpression -> lvalue = rvalue .)
    VAR             reduce using rule 29 (AssignmentExpression -> lvalue = rvalue .)
    $end            reduce using rule 29 (AssignmentExpression -> lvalue = rvalue .)
    }               reduce using rule 29 (AssignmentExpression -> lvalue = rvalue .)
    RETURN          reduce using rule 29 (AssignmentExpression -> lvalue = rvalue .)


state 28

    (24) rvalue -> Identifier .
    (22) FunctionCall -> Identifier . ( )
    (23) FunctionCall -> Identifier . ( arg_list )
    (14) UnaryExpression -> Identifier .
  ! reduce/reduce conflict for CODE resolved using rule 24 (rvalue -> Identifier .)
  ! reduce/reduce conflict for ID resolved using rule 24 (rvalue -> Identifier .)
  ! reduce/reduce conflict for VAR resolved using rule 24 (rvalue -> Identifier .)
  ! reduce/reduce conflict for $end resolved using rule 24 (rvalue -> Identifier .)
  ! reduce/reduce conflict for } resolved using rule 24 (rvalue -> Identifier .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (rvalue -> Identifier .)
    CODE            reduce using rule 24 (rvalue -> Identifier .)
    ID              reduce using rule 24 (rvalue -> Identifier .)
    VAR             reduce using rule 24 (rvalue -> Identifier .)
    $end            reduce using rule 24 (rvalue -> Identifier .)
    }               reduce using rule 24 (rvalue -> Identifier .)
    RETURN          reduce using rule 24 (rvalue -> Identifier .)
    (               shift and go to state 43
    /               reduce using rule 14 (UnaryExpression -> Identifier .)
    *               reduce using rule 14 (UnaryExpression -> Identifier .)
    -               reduce using rule 14 (UnaryExpression -> Identifier .)
    +               reduce using rule 14 (UnaryExpression -> Identifier .)


state 29

    (25) rvalue -> Expression .
    CODE            reduce using rule 25 (rvalue -> Expression .)
    ID              reduce using rule 25 (rvalue -> Expression .)
    VAR             reduce using rule 25 (rvalue -> Expression .)
    $end            reduce using rule 25 (rvalue -> Expression .)
    }               reduce using rule 25 (rvalue -> Expression .)
    RETURN          reduce using rule 25 (rvalue -> Expression .)


state 30

    (26) rvalue -> FunctionCall .
    CODE            reduce using rule 26 (rvalue -> FunctionCall .)
    ID              reduce using rule 26 (rvalue -> FunctionCall .)
    VAR             reduce using rule 26 (rvalue -> FunctionCall .)
    $end            reduce using rule 26 (rvalue -> FunctionCall .)
    }               reduce using rule 26 (rvalue -> FunctionCall .)
    RETURN          reduce using rule 26 (rvalue -> FunctionCall .)


state 31

    (12) Expression -> BinaryOperation .
    CODE            reduce using rule 12 (Expression -> BinaryOperation .)
    ID              reduce using rule 12 (Expression -> BinaryOperation .)
    VAR             reduce using rule 12 (Expression -> BinaryOperation .)
    $end            reduce using rule 12 (Expression -> BinaryOperation .)
    }               reduce using rule 12 (Expression -> BinaryOperation .)
    RETURN          reduce using rule 12 (Expression -> BinaryOperation .)
    )               reduce using rule 12 (Expression -> BinaryOperation .)


state 32

    (13) UnaryExpression -> ( . Expression )
    (12) Expression -> . BinaryOperation
    (11) BinaryOperation -> . addative
    (8) addative -> . addative - multiplicative
    (9) addative -> . addative + multiplicative
    (10) addative -> . multiplicative
    (5) multiplicative -> . multiplicative / UnaryExpression
    (6) multiplicative -> . multiplicative * UnaryExpression
    (7) multiplicative -> . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    (1) Identifier -> . ID
    (               shift and go to state 32
    NUMBER          shift and go to state 36
    ID              shift and go to state 11

    Expression                     shift and go to state 44
    BinaryOperation                shift and go to state 31
    addative                       shift and go to state 33
    multiplicative                 shift and go to state 34
    UnaryExpression                shift and go to state 35
    Identifier                     shift and go to state 42

state 33

    (11) BinaryOperation -> addative .
    (8) addative -> addative . - multiplicative
    (9) addative -> addative . + multiplicative
    CODE            reduce using rule 11 (BinaryOperation -> addative .)
    ID              reduce using rule 11 (BinaryOperation -> addative .)
    VAR             reduce using rule 11 (BinaryOperation -> addative .)
    $end            reduce using rule 11 (BinaryOperation -> addative .)
    }               reduce using rule 11 (BinaryOperation -> addative .)
    RETURN          reduce using rule 11 (BinaryOperation -> addative .)
    )               reduce using rule 11 (BinaryOperation -> addative .)
    -               shift and go to state 45
    +               shift and go to state 46


state 34

    (10) addative -> multiplicative .
    (5) multiplicative -> multiplicative . / UnaryExpression
    (6) multiplicative -> multiplicative . * UnaryExpression
    -               reduce using rule 10 (addative -> multiplicative .)
    +               reduce using rule 10 (addative -> multiplicative .)
    CODE            reduce using rule 10 (addative -> multiplicative .)
    ID              reduce using rule 10 (addative -> multiplicative .)
    VAR             reduce using rule 10 (addative -> multiplicative .)
    $end            reduce using rule 10 (addative -> multiplicative .)
    }               reduce using rule 10 (addative -> multiplicative .)
    RETURN          reduce using rule 10 (addative -> multiplicative .)
    )               reduce using rule 10 (addative -> multiplicative .)
    /               shift and go to state 47
    *               shift and go to state 48


state 35

    (7) multiplicative -> UnaryExpression .
    /               reduce using rule 7 (multiplicative -> UnaryExpression .)
    *               reduce using rule 7 (multiplicative -> UnaryExpression .)
    -               reduce using rule 7 (multiplicative -> UnaryExpression .)
    +               reduce using rule 7 (multiplicative -> UnaryExpression .)
    CODE            reduce using rule 7 (multiplicative -> UnaryExpression .)
    ID              reduce using rule 7 (multiplicative -> UnaryExpression .)
    VAR             reduce using rule 7 (multiplicative -> UnaryExpression .)
    $end            reduce using rule 7 (multiplicative -> UnaryExpression .)
    }               reduce using rule 7 (multiplicative -> UnaryExpression .)
    RETURN          reduce using rule 7 (multiplicative -> UnaryExpression .)
    )               reduce using rule 7 (multiplicative -> UnaryExpression .)


state 36

    (15) UnaryExpression -> NUMBER .
    /               reduce using rule 15 (UnaryExpression -> NUMBER .)
    *               reduce using rule 15 (UnaryExpression -> NUMBER .)
    -               reduce using rule 15 (UnaryExpression -> NUMBER .)
    +               reduce using rule 15 (UnaryExpression -> NUMBER .)
    CODE            reduce using rule 15 (UnaryExpression -> NUMBER .)
    ID              reduce using rule 15 (UnaryExpression -> NUMBER .)
    VAR             reduce using rule 15 (UnaryExpression -> NUMBER .)
    $end            reduce using rule 15 (UnaryExpression -> NUMBER .)
    }               reduce using rule 15 (UnaryExpression -> NUMBER .)
    RETURN          reduce using rule 15 (UnaryExpression -> NUMBER .)
    )               reduce using rule 15 (UnaryExpression -> NUMBER .)


state 37

    (41) CodeDeclaration -> CODE Declaration ( . )
    (42) CodeDeclaration -> CODE Declaration ( . arg_declaration_list )
    (35) arg_declaration_list -> . arg_declaration
    (36) arg_declaration_list -> . arg_declaration_list arg_declaration
    (37) arg_declaration -> . Declaration ,
    (38) arg_declaration -> . Declaration
    (3) Declaration -> . Identifier : Type
    (1) Identifier -> . ID
    )               shift and go to state 50
    ID              shift and go to state 11

    Declaration                    shift and go to state 49
    arg_declaration_list           shift and go to state 51
    arg_declaration                shift and go to state 52
    Identifier                     shift and go to state 18

state 38

    (3) Declaration -> Identifier : . Type
    (2) Type -> . ID
    ID              shift and go to state 54

    Type                           shift and go to state 53

state 39

    (40) CodeDefinition -> { statements } .
    CODE            reduce using rule 40 (CodeDefinition -> { statements } .)
    ID              reduce using rule 40 (CodeDefinition -> { statements } .)
    VAR             reduce using rule 40 (CodeDefinition -> { statements } .)
    $end            reduce using rule 40 (CodeDefinition -> { statements } .)


state 40

    (33) statements -> statements statement .
    }               reduce using rule 33 (statements -> statements statement .)
    VAR             reduce using rule 33 (statements -> statements statement .)
    RETURN          reduce using rule 33 (statements -> statements statement .)
    ID              reduce using rule 33 (statements -> statements statement .)


state 41

    (16) Return -> RETURN Expression .
    }               reduce using rule 16 (Return -> RETURN Expression .)
    VAR             reduce using rule 16 (Return -> RETURN Expression .)
    RETURN          reduce using rule 16 (Return -> RETURN Expression .)
    ID              reduce using rule 16 (Return -> RETURN Expression .)


state 42

    (14) UnaryExpression -> Identifier .
    /               reduce using rule 14 (UnaryExpression -> Identifier .)
    *               reduce using rule 14 (UnaryExpression -> Identifier .)
    -               reduce using rule 14 (UnaryExpression -> Identifier .)
    +               reduce using rule 14 (UnaryExpression -> Identifier .)
    }               reduce using rule 14 (UnaryExpression -> Identifier .)
    VAR             reduce using rule 14 (UnaryExpression -> Identifier .)
    RETURN          reduce using rule 14 (UnaryExpression -> Identifier .)
    ID              reduce using rule 14 (UnaryExpression -> Identifier .)
    )               reduce using rule 14 (UnaryExpression -> Identifier .)
    CODE            reduce using rule 14 (UnaryExpression -> Identifier .)
    $end            reduce using rule 14 (UnaryExpression -> Identifier .)


state 43

    (22) FunctionCall -> Identifier ( . )
    (23) FunctionCall -> Identifier ( . arg_list )
    (20) arg_list -> . arg_list arg
    (21) arg_list -> . arg
    (18) arg -> . Identifier ,
    (19) arg -> . Identifier
    (1) Identifier -> . ID
    )               shift and go to state 56
    ID              shift and go to state 11

    Identifier                     shift and go to state 55
    arg_list                       shift and go to state 57
    arg                            shift and go to state 58

state 44

    (13) UnaryExpression -> ( Expression . )
    )               shift and go to state 59


state 45

    (8) addative -> addative - . multiplicative
    (5) multiplicative -> . multiplicative / UnaryExpression
    (6) multiplicative -> . multiplicative * UnaryExpression
    (7) multiplicative -> . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    (1) Identifier -> . ID
    (               shift and go to state 32
    NUMBER          shift and go to state 36
    ID              shift and go to state 11

    multiplicative                 shift and go to state 60
    UnaryExpression                shift and go to state 35
    Identifier                     shift and go to state 42

state 46

    (9) addative -> addative + . multiplicative
    (5) multiplicative -> . multiplicative / UnaryExpression
    (6) multiplicative -> . multiplicative * UnaryExpression
    (7) multiplicative -> . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    (1) Identifier -> . ID
    (               shift and go to state 32
    NUMBER          shift and go to state 36
    ID              shift and go to state 11

    multiplicative                 shift and go to state 61
    UnaryExpression                shift and go to state 35
    Identifier                     shift and go to state 42

state 47

    (5) multiplicative -> multiplicative / . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    (1) Identifier -> . ID
    (               shift and go to state 32
    NUMBER          shift and go to state 36
    ID              shift and go to state 11

    UnaryExpression                shift and go to state 62
    Identifier                     shift and go to state 42

state 48

    (6) multiplicative -> multiplicative * . UnaryExpression
    (13) UnaryExpression -> . ( Expression )
    (14) UnaryExpression -> . Identifier
    (15) UnaryExpression -> . NUMBER
    (1) Identifier -> . ID
    (               shift and go to state 32
    NUMBER          shift and go to state 36
    ID              shift and go to state 11

    UnaryExpression                shift and go to state 63
    Identifier                     shift and go to state 42

state 49

    (37) arg_declaration -> Declaration . ,
    (38) arg_declaration -> Declaration .
    ,               shift and go to state 64
    )               reduce using rule 38 (arg_declaration -> Declaration .)
    ID              reduce using rule 38 (arg_declaration -> Declaration .)


state 50

    (41) CodeDeclaration -> CODE Declaration ( ) .
    {               reduce using rule 41 (CodeDeclaration -> CODE Declaration ( ) .)


state 51

    (42) CodeDeclaration -> CODE Declaration ( arg_declaration_list . )
    (36) arg_declaration_list -> arg_declaration_list . arg_declaration
    (37) arg_declaration -> . Declaration ,
    (38) arg_declaration -> . Declaration
    (3) Declaration -> . Identifier : Type
    (1) Identifier -> . ID
    )               shift and go to state 65
    ID              shift and go to state 11

    Declaration                    shift and go to state 49
    arg_declaration                shift and go to state 66
    Identifier                     shift and go to state 18

state 52

    (35) arg_declaration_list -> arg_declaration .
    )               reduce using rule 35 (arg_declaration_list -> arg_declaration .)
    ID              reduce using rule 35 (arg_declaration_list -> arg_declaration .)


state 53

    (3) Declaration -> Identifier : Type .
    (               reduce using rule 3 (Declaration -> Identifier : Type .)
    =               reduce using rule 3 (Declaration -> Identifier : Type .)
    }               reduce using rule 3 (Declaration -> Identifier : Type .)
    VAR             reduce using rule 3 (Declaration -> Identifier : Type .)
    RETURN          reduce using rule 3 (Declaration -> Identifier : Type .)
    ID              reduce using rule 3 (Declaration -> Identifier : Type .)
    ,               reduce using rule 3 (Declaration -> Identifier : Type .)
    )               reduce using rule 3 (Declaration -> Identifier : Type .)


state 54

    (2) Type -> ID .
    (               reduce using rule 2 (Type -> ID .)
    =               reduce using rule 2 (Type -> ID .)
    }               reduce using rule 2 (Type -> ID .)
    VAR             reduce using rule 2 (Type -> ID .)
    RETURN          reduce using rule 2 (Type -> ID .)
    ID              reduce using rule 2 (Type -> ID .)
    ,               reduce using rule 2 (Type -> ID .)
    )               reduce using rule 2 (Type -> ID .)


state 55

    (18) arg -> Identifier . ,
    (19) arg -> Identifier .
    ,               shift and go to state 67
    )               reduce using rule 19 (arg -> Identifier .)
    ID              reduce using rule 19 (arg -> Identifier .)


state 56

    (22) FunctionCall -> Identifier ( ) .
    CODE            reduce using rule 22 (FunctionCall -> Identifier ( ) .)
    ID              reduce using rule 22 (FunctionCall -> Identifier ( ) .)
    VAR             reduce using rule 22 (FunctionCall -> Identifier ( ) .)
    $end            reduce using rule 22 (FunctionCall -> Identifier ( ) .)
    }               reduce using rule 22 (FunctionCall -> Identifier ( ) .)
    RETURN          reduce using rule 22 (FunctionCall -> Identifier ( ) .)


state 57

    (23) FunctionCall -> Identifier ( arg_list . )
    (20) arg_list -> arg_list . arg
    (18) arg -> . Identifier ,
    (19) arg -> . Identifier
    (1) Identifier -> . ID
    )               shift and go to state 68
    ID              shift and go to state 11

    Identifier                     shift and go to state 55
    arg                            shift and go to state 69

state 58

    (21) arg_list -> arg .
    )               reduce using rule 21 (arg_list -> arg .)
    ID              reduce using rule 21 (arg_list -> arg .)


state 59

    (13) UnaryExpression -> ( Expression ) .
    /               reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    *               reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    -               reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    +               reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    CODE            reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    ID              reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    VAR             reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    $end            reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    }               reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    RETURN          reduce using rule 13 (UnaryExpression -> ( Expression ) .)
    )               reduce using rule 13 (UnaryExpression -> ( Expression ) .)


state 60

    (8) addative -> addative - multiplicative .
    (5) multiplicative -> multiplicative . / UnaryExpression
    (6) multiplicative -> multiplicative . * UnaryExpression
    -               reduce using rule 8 (addative -> addative - multiplicative .)
    +               reduce using rule 8 (addative -> addative - multiplicative .)
    CODE            reduce using rule 8 (addative -> addative - multiplicative .)
    ID              reduce using rule 8 (addative -> addative - multiplicative .)
    VAR             reduce using rule 8 (addative -> addative - multiplicative .)
    $end            reduce using rule 8 (addative -> addative - multiplicative .)
    }               reduce using rule 8 (addative -> addative - multiplicative .)
    RETURN          reduce using rule 8 (addative -> addative - multiplicative .)
    )               reduce using rule 8 (addative -> addative - multiplicative .)
    /               shift and go to state 47
    *               shift and go to state 48


state 61

    (9) addative -> addative + multiplicative .
    (5) multiplicative -> multiplicative . / UnaryExpression
    (6) multiplicative -> multiplicative . * UnaryExpression
    -               reduce using rule 9 (addative -> addative + multiplicative .)
    +               reduce using rule 9 (addative -> addative + multiplicative .)
    CODE            reduce using rule 9 (addative -> addative + multiplicative .)
    ID              reduce using rule 9 (addative -> addative + multiplicative .)
    VAR             reduce using rule 9 (addative -> addative + multiplicative .)
    $end            reduce using rule 9 (addative -> addative + multiplicative .)
    }               reduce using rule 9 (addative -> addative + multiplicative .)
    RETURN          reduce using rule 9 (addative -> addative + multiplicative .)
    )               reduce using rule 9 (addative -> addative + multiplicative .)
    /               shift and go to state 47
    *               shift and go to state 48


state 62

    (5) multiplicative -> multiplicative / UnaryExpression .
    /               reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    *               reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    -               reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    +               reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    CODE            reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    ID              reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    VAR             reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    $end            reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    }               reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    RETURN          reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)
    )               reduce using rule 5 (multiplicative -> multiplicative / UnaryExpression .)


state 63

    (6) multiplicative -> multiplicative * UnaryExpression .
    /               reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    *               reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    -               reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    +               reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    CODE            reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    ID              reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    VAR             reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    $end            reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    }               reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    RETURN          reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)
    )               reduce using rule 6 (multiplicative -> multiplicative * UnaryExpression .)


state 64

    (37) arg_declaration -> Declaration , .
    )               reduce using rule 37 (arg_declaration -> Declaration , .)
    ID              reduce using rule 37 (arg_declaration -> Declaration , .)


state 65

    (42) CodeDeclaration -> CODE Declaration ( arg_declaration_list ) .
    {               reduce using rule 42 (CodeDeclaration -> CODE Declaration ( arg_declaration_list ) .)


state 66

    (36) arg_declaration_list -> arg_declaration_list arg_declaration .
    )               reduce using rule 36 (arg_declaration_list -> arg_declaration_list arg_declaration .)
    ID              reduce using rule 36 (arg_declaration_list -> arg_declaration_list arg_declaration .)


state 67

    (18) arg -> Identifier , .
    )               reduce using rule 18 (arg -> Identifier , .)
    ID              reduce using rule 18 (arg -> Identifier , .)


state 68

    (23) FunctionCall -> Identifier ( arg_list ) .
    CODE            reduce using rule 23 (FunctionCall -> Identifier ( arg_list ) .)
    ID              reduce using rule 23 (FunctionCall -> Identifier ( arg_list ) .)
    VAR             reduce using rule 23 (FunctionCall -> Identifier ( arg_list ) .)
    $end            reduce using rule 23 (FunctionCall -> Identifier ( arg_list ) .)
    }               reduce using rule 23 (FunctionCall -> Identifier ( arg_list ) .)
    RETURN          reduce using rule 23 (FunctionCall -> Identifier ( arg_list ) .)


state 69

    (20) arg_list -> arg_list arg .
    )               reduce using rule 20 (arg_list -> arg_list arg .)
    ID              reduce using rule 20 (arg_list -> arg_list arg .)


Conflicts:

shift/reduce conflict for ID in state 26 resolved as shift
reduce/reduce conflict in state 28 resolved using rule rvalue -> Identifier
rejected rule (UnaryExpression -> Identifier) in state 28